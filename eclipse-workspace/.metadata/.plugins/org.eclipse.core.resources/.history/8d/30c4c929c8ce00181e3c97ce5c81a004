package priorityQueue;

	public class MinHeap<T extends Comparable<T>> {
	
		private T[] heapArray;
		private int maxSize;
		private int currentSize;


		public MinHeap(int maxSize) {
			heapArray = (T[])new Comparable[maxSize];
			this.maxSize = maxSize;
			currentSize = 0;
		}

		public MinHeap(int maxSize, T[] values) {
			heapArray = (T[])new Comparable[maxSize];
			this.maxSize = maxSize;
			currentSize = 0;
	
			createBTree(values);
			buildHeap();
		}
		
		public int size() {
			return currentSize;
		}
		
		private boolean isRoot(int index) {
			if (index == 0) {
				return true;
			} else {
				return false;
			}
		}
		
		private boolean isLeaf(int index) {
			return (index >= currentSize/2) && (index < currentSize);
		}
		
		private int left(int index) {
			if (isLeaf(index)) {
				return -1;
			}
			return 2*index + 2;
		}
		
		private int right(int index) {
			if (isLeaf(index)) {
				return -1;
			}
			return 2*index + 2;
		}
		
		private int parent(int index) {
			if (index <= 0) {
				return -1;
			}
			return (index-1)/2;
		}
		
		private boolean lessThan(T value1, T value2) {
			if (value1.compareTo(value2) < 0) {
				return true;
			} else {
				return false;
			}
		}
		
		private boolean largerThan(T value1, T value2) {
			if (value1.compareTo(value2) > 0) {
				return true;
			} else {
				return false;
			}
		}
		
		private void swap(int index1, int index2) {
			T temp = heapArray[index1];
			heapArray[index1] = heapArray[index2];
			heapArray[index2] = temp;
		}
		
		private void moveUp(int index) {
			while (!istRoot(index) && lessThan(heapArray[index], heapArray[parent(index)])) {
				swap(index, parent(index));
				index = parent(index);
			}
		}
}